%{
Integrating error_ellipse code from Vincent Spruyt                           
Adapted from https://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/          

This cade requires following codes:
    CSV_Extraction.m
    Statistics and Machine Learning Toolbox


Input1(optin):  a tif file of a Z-projection. This is for making figure.
Input2       :  CSV.files generated by simple neurite tracer (SNT) imageJ/plugin. Each file have branch positions of each axon arbor. 


%}


function A = ellipse_fitting()
%%%%%%%%%%%%%%%%%%%%%%%
% parameters
%%%%%%%%%%%%%%%%%%%%%%%
chisquare_val_95 = 2.4477; % 2.4477 = sqrt(chi2inv(0.95,2))   confident 95  freedom 2
chisquare_val_30 = 0.8446; % confident 30
chisquare_val_50 = 1.1774; % confident 50
chisquare_val_70 = 1.5518; % confident 70
chisquare_val_80 = 1.7941; % confident 80 
chisquare_val_90 = 2.1460; % confident 90
chisquare_val_99 = 3.0349; % confident 99

chisquare_val = chisquare_val_90; % select chisquare_val. default = 90

overlay_flag = 0; % For figure. if you want to plot the ellipse on a z-projection image
plot_eigen_flag = 1; % If you want draw eigenvectors with eigenvalues on the graph
plot_marker_size = 20; % def 20
line_bold =3;  %def 3
black_back =0; % If you want to plot the ellipse on a black background image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%

abs_angle = []; % absolute vale of orientation angle of covariance ellipse
major_length = []; 
ellip_width = [];  
minor_length = []; 
ellip_height = []; 
area = []; 
length_ratio = []; % major_length/minor_length

% for overlaid on a z-projection image 
if overlay_flag == 1
    [tif_file_name, tif_path, tif_index] = uigetfile({  '*.tif','TIF (*.tif)'}, 'Select a tif file of z projection.');
    if isequal(tif_file_name,0) | isequal(tif_path,0)
        disp('User pressed cancel')
        A = [];
        return
    end
    A = imread_big([tif_path, tif_file_name]);
    imshow(A)
    hold on
    A =[]
end


% open CSV files
[cv_file_name, cv_path, cv_index] = uigetfile({  '*.csv','csv image (*.csv)'}, 'Select one or several CSV files generated by SNT (using +CTRL or +SHIFT)','MultiSelect', 'on');
    if isequal(cv_file_name,0) | isequal(cv_path,0)
    disp('User pressed cancel')
    A = [];
    return
    end
    
    % num_opened_file    
    if iscell(cv_file_name) 
        num_opened_file = length(cv_file_name);
    else
         disp('Select multiple files')
         A = [];
         return
    end
    
  for cur_num = 1:num_opened_file
        A = [];
         try
            T = readtable([cv_path, cv_file_name{cur_num}]);
         catch
             disp('cant open CSV file!')
             A = [];
             return
         end
         
      
         
         try
           X = round(T{:,'StartX'});
           Y = round(T{:,'StartY'});
           eX = round(T{:,'EndX'});
           eY = round(T{:,'EndY'});
           L = round(T{:,'PathLength'});
         catch
           disp('file seems to be broken.')
           A =[];
           return
         end
         
         try
             Tag_d = T{:,'SWCType'};
         catch
             disp('file seems to be broken.')
             A =[];
             return
         end
         Z = [];
         for frame = 1:length(Tag_d)
             switch Tag_d{frame}
                 case 'undefined'            % branch 
                     Z(frame, 1) = 1; 
                 case '(basal) dendrite'     % Addition
                     Z(frame, 1) = 2;
                 case 'apical dendrite'      % Elimination
                     Z(frame, 1) = 3;
                 case 'axon'                 % Elongation
                     Z(frame, 1) = 4;
                 case 'soma'                 % retract
                     Z(frame, 1) = 5;
                 otherwise                   % others = branch
                     Z(frame, 1) = 1;
             end
         end
         %Extracted data    [type, x_position, y_position, end_x_position, end_y_position, PathLength]
         A =[Z,X,Y,eX,eY,L];
         x = A(:,2);
         y = A(:,3);
         data = [x,y];
         
         
         
         % Calculate the eigenvectors and eigenvalues
         covariance = cov(data);  
         [eigenvec, eigenval] = eig(covariance); % [V,D]=eig(A)ã€€ A*V=V*D
         
         % Get the index of the largest eigenvector
         [largest_eigenvec_ind_c, r] = find(eigenval == max(max(eigenval)));
         largest_eigenvec = eigenvec(:, largest_eigenvec_ind_c);
         
         
         
         % Get the largest eigenvalue
         largest_eigenval = max(max(eigenval));
         
         
         % Get the smallest eigenvector and eigenvalue
         if(largest_eigenvec_ind_c == 1)
             smallest_eigenval = max(eigenval(:,2))
             smallest_eigenvec = eigenvec(:,2);
         else
             smallest_eigenval = max(eigenval(:,1))
             smallest_eigenvec = eigenvec(1,:);
         end
         
         
         % Calculate the angle between the x-axis and the largest eigenvector
         angle = atan2(largest_eigenvec(2), largest_eigenvec(1));
         
         
         
         % orientation angles are between -pi and pi.
         % Shift it such that the angle is between 0 and 2pi
         if(angle < 0)
             angle = angle + 2*pi;
         end
         
         % Range of degree angle [0-90]
         abs_angle = atan2(abs(largest_eigenvec(2)), abs(largest_eigenvec(1)));
         abs_angle = rad2deg(abs_angle);
         
         % Get the coordinates of the data mean
         ment = mean(data);
         X0 = ment(1);
         Y0 = ment(2);
         
         % Get the n% confidence interval error ellipse
         a = chisquare_val * sqrt(largest_eigenval);   % major axis   2*a = 2*(variance of x) * sqrt(chi2inv(confident,freedom)))
         b = chisquare_val * sqrt(smallest_eigenval);  % minor axis   2*b = 2*(variance of y) * sqrt(chi2inv(confident,freedom)))
         
         
         %Major length and minor lenght of the covariance ellipse
         major_length = 2*a;
         minor_length = 2*b;
         
         % the ellipse in x and y coordinates 
         theta = linspace(0, 2 * pi);
         ellipse_x  = a * cos(theta);
         ellipse_y  = b * sin(theta);
         
         
         %Define a rotation matrix
         R = [ cos(angle) sin(angle); -sin(angle) cos(angle) ];
         
         
         %Rrotate the ellipse to some angle phi
         r_ellipse = [ellipse_x;ellipse_y]' * R;
    
              
         if black_back == 1
             I = uint8(zeros(512,512));
             imshow(I)
             hold on
         end
     
         % Draw the error ellipse
         plot(r_ellipse(:,1) + X0,r_ellipse(:,2) + Y0,'-','LineWidth',line_bold,'Color',[0.7 0 0]);   
         hold on 
 
         
         % ellipse width and height  
         ellip_width_max = max(r_ellipse(:,1) + X0);
         ellip_width_min = min(r_ellipse(:,1) + X0);
         ellip_width = ellip_width_max - ellip_width_min;
         
         ellip_height_max = max(r_ellipse(:,2) + Y0);
         ellip_height_min = min(r_ellipse(:,2) + Y0);
         ellip_height = ellip_height_max - ellip_height_min;
          
   
         % Plot the original data
         plot(data(:,1), data(:,2), '.','MarkerSize',plot_marker_size,'Color','g');  %'MarkerEdgeColor','g'
         mindata = min(min(data));
         maxdata = max(max(data));
         xlim([mindata-3, maxdata+3]);
         ylim([mindata-3, maxdata+3]);
         hold on
         axis equal
        
         if plot_eigen_flag == 1
             % Plot the eigenvectors
             quiver(X0, Y0, largest_eigenvec(1)*sqrt(largest_eigenval), largest_eigenvec(2)*sqrt(largest_eigenval), '-b', 'LineWidth',line_bold);
             quiver(X0, Y0, smallest_eigenvec(1)*sqrt(smallest_eigenval), smallest_eigenvec(2)*sqrt(smallest_eigenval), '-b', 'LineWidth',line_bold);
             hold on
         end
         
         % Set the axis labels
         hXLabel = xlabel('x');
         hYLabel = ylabel('y');

         
         
         

         %Area of the covaliance ellipse
         area = pi * a * b;
         
         length_ratio = major_length / minor_length;
         wh_ratio = ellip_width / ellip_height
         
         % SS = Summary_Structure 
         if cur_num == 1
             SS = struct( 'File_Name', cv_file_name{cur_num},...
                 'abs_angle',abs_angle,...
                 'major_length',major_length,...
                 'minor_length',minor_length,...
                 'ellip_width',ellip_width,...
                 'ellip_height',ellip_height,...
                 'area',area,...
                 'ratio_of_major_length_to_minor_length',length_ratio,...
                 'ratio_of_width_to_height', wh_ratio);
         else
             SS(cur_num).File_Name = cv_file_name{cur_num};
             SS(cur_num).abs_angle = abs_angle;
             SS(cur_num).major_length = major_length;
             SS(cur_num).minor_length = minor_length;
             SS(cur_num).ellip_width = ellip_width;
             SS(cur_num).ellip_height = ellip_height;
             SS(cur_num).area = area;
             SS(cur_num).ratio_of_major_length_to_minor_length = length_ratio;
             SS(cur_num).ratio_of_width_to_height = wh_ratio;
         end  
  end
  
  % Save SS as CSV
  T = struct2table(SS);
  writetable(T,'Summary_Average_for_error_ellipse.csv'); 
  A = 1;
  
end
